"""
Author: Yifei Wang
Date: 2018-10-30
Description: This script will sample the curve generated by control points, and save them for further operation
"""

import os
import numpy as np
import random
from scipy.interpolate import CubicSpline
import matplotlib.pyplot as plt


# the curve control points data of out shape
DROP_OUT_SHAPE_CONTROL_POINTS = r"C:\Users\Administrator\Documents\GitHub\AdhereRainDropModel\Data\saved\control_points\out_shape.npy"

# the curve control points data of peak height
DROP_PEAK_HEIGHT_CONTROL_POINTS = r"C:\Users\Administrator\Documents\GitHub\AdhereRainDropModel\Data\saved\control_points\peak_height.npy"

# the curve control points data of peak shape
DROP_PEAK_SHAPE_CONTROL_POINTS = r"C:\Users\Administrator\Documents\GitHub\AdhereRainDropModel\Data\saved\control_points\peak_shape.npy"

# the save directory of collected points
SAVE_DIR_OF_COLLECTED_POINTS = r"C:\Users\Administrator\Documents\GitHub\AdhereRainDropModel\Data\saved\sampled"

# save file name of out shape x points
OUT_SHAPE_POINTS_X_FILE_NAME = "out_shape_x"

# save file name of out shape y points
OUT_SHAPE_POINTS_Y_FILE_NAME = "out_shape_y"

# save file name of out shape x points
OUT_PEAK_HEIGHT_POINTS_FILE_NAME = "peak_height"

# save file name of out shape x points
OUT_PEAK_SHAPE_POINTS_FILE_NAME = "peak_shape"


def _randomly_select_control_points_configuration(cp_list_os, cp_list_ph, cp_list_ps, is_debug=False):
    """
    randomly select a valid configuration among the cp list, and return the control points collection for this configuration
    :param cp_list_os: the out shape control points list
    :param cp_list_ph: the peak height control points list
    :param cp_list_ps: the peak shape control points list
    :param is_debug: whether is in debugging mode, if True, will always return 1st height peak, 1st out shape map and 1st peak shape
    :return: control points of out shape, peak height and peak shape
    """
    peak_height_amount = cp_list_ph.shape[0]
    select_ph_index = int(random.uniform(0, peak_height_amount))

    out_shape_name_list = cp_list_os[:, -1, 0]
    out_shape_amount = cp_list_os.shape[0]
    select_os_index = int(random.uniform(0, out_shape_amount))
    select_os_name = out_shape_name_list[select_os_index]

    candidate_ps_list = list()
    for ps_cp in cp_list_ps:
        if ps_cp[-1][0] == select_os_name:
            candidate_ps_list.append(ps_cp[:, -1])
    candidate_ps_amount = len(candidate_ps_list)
    select_ps_index = int(random.uniform(0, candidate_ps_amount))

    if is_debug is True:
        # NOTE: debug will not ensure the out shape and peak shape are paired
        select_ph_index = 0
        select_os_index = 0
        select_ps_index = 0

    select_ph_cp = cp_list_ph[select_ph_index, :, :]
    select_os_cp = cp_list_os[select_os_index, :-1, :]
    select_ps_cp = cp_list_ps[select_ps_index, :-1, :]

    return select_os_cp, select_ph_cp, select_ps_cp


def _construct_spline_function(select_os_cp, select_ph_cp, select_ps_cp, enable_debugging=False):
    """
    generate the spline function based on control points provided
    :param select_os_cp: the out shape control points
    :param select_ph_cp: the peak height control points
    :param select_ps_cp: the peak shape control points
    :return: the spline function based on these control points
    """
    x_coord = [p[0] for p in select_ph_cp]
    y_coord = [p[1] for p in select_ph_cp]
    ph_function = CubicSpline(x_coord, y_coord)

    x_coord = [p[0] for p in select_ps_cp]
    y_coord = [p[1] for p in select_ps_cp]
    ps_function = CubicSpline(x_coord, y_coord)

    theta = 2 * np.pi * np.linspace(0, 1, len(select_os_cp))
    os_function = CubicSpline(theta, select_os_cp, bc_type='periodic')

    if enable_debugging is True:
        xs = np.arange(0, 1, 0.001)
        plt.plot(xs, ph_function(xs), label="PeakHeight")
        plt.plot(xs, ps_function(xs), label="PeakShape")
        xs = np.pi * 2 * xs
        plt.plot(os_function(xs)[:, 0], os_function(xs)[:, 1], label='OutShape')
        plt.legend()
        plt.show()

    return os_function, ps_function, ph_function


def _sample_along_function(os_function, ps_function, ph_function, sample_strength, enable_debugging=False):
    """
    sample along the function
    :param os_function:the out shape function, Note, the sample at this function will be doubled
    :param ps_function:the peak shape function
    :param ph_function: the peak height function
    :param sample_strength: a scalar number, to how many samples will be generate
    :param enable_debugging: whether enable debugging plot for preview
    :return: sampled
    """
    xs = np.linspace(0, 1, sample_strength)
    peak_height_collection = ph_function(xs)
    peak_shape_collection = ps_function(xs)

    xs = np.linspace(0, 1, sample_strength * 2) * 2 * np.pi
    out_shape = os_function(xs)
    out_shape_x_collection = out_shape[:, 0]
    out_shape_y_collection = out_shape[:, 1]

    if enable_debugging is True:
        xs = np.linspace(0, 1, sample_strength)
        plt.plot(xs, peak_height_collection, label="PeakHeight")
        plt.plot(xs, peak_shape_collection, label="PeakShape")
        plt.plot(out_shape_x_collection, out_shape_y_collection, label='OutShape')
        plt.legend()
        plt.show()

    return out_shape_x_collection, out_shape_y_collection, peak_height_collection, peak_shape_collection


def load_control_points(out_shape_file, peak_height_file, peak_shape_file):
    """
    load all control points data
    :param out_shape_file: the out shape file
    :param peak_height_file: the peak height file
    :param peak_shape_file: the peak shape file
    :return: out shape control points, peak height control points, peak shape control points
    """
    out_shape_control_points = np.load(out_shape_file)
    peak_height_control_points = np.load(peak_height_file)
    peak_shape_control_points = np.load(peak_shape_file)

    return out_shape_control_points, peak_height_control_points, peak_shape_control_points


def collect_generated_shapes(cp_list_os, cp_list_ph, cp_list_ps, sample_strength, generate_amount=10):
    """
    save the normalized drop parameters as numpy save object
    :param cp_list_os: the out shape control points list
    :param cp_list_ph: the peak height control points list
    :param cp_list_ps: the peak shape control points list
    :param sample_strength: the sample strength along the function simulated
    :param generate_amount: the generated amount
    :return: the collected sample points
    """

    out_shape_x = np.zeros([generate_amount, sample_strength * 2])
    out_shape_y = np.zeros([generate_amount, sample_strength * 2])
    peak_shape = np.zeros([generate_amount, sample_strength])
    peak_height = np.zeros([generate_amount, sample_strength])

    generation_count = 0
    while generation_count < generate_amount:
        picked_os_cp, picked_ph_cp, picked_ps_cp = _randomly_select_control_points_configuration(cp_list_os, cp_list_ph, cp_list_ps)
        func_os, func_ps, func_ph = _construct_spline_function(picked_os_cp, picked_ph_cp, picked_ps_cp)
        os_x, os_y, ph, ps = _sample_along_function(func_os, func_ps, func_ph, sample_strength)

        out_shape_x[generation_count, :] = os_x
        out_shape_y[generation_count, :] = os_y
        peak_shape[generation_count, :] = ps
        peak_height[generation_count, :] = ph

        generation_count += 1

    return out_shape_x, out_shape_y, peak_shape, peak_height


def save_shapes(out_shape_x, out_shape_y, peak_shape, peak_height,
                save_dir,
                file_name_out_shape_x, file_name_out_shape_y, file_name_peak_shape, file_name_peak_height):
    """
    save the shape data into numpy save object
    :param out_shape_x: the out shape sampled from x axis
    :param out_shape_y: the out shape sampled form y axis
    :param peak_shape: the peak shape sampled
    :param peak_height: the peak height sampled
    :param save_dir: the directory to save to
    :param file_name_out_shape_x: the file name for out shape x data
    :param file_name_out_shape_y: the file name for out shape y data
    :param file_name_peak_shape: the file name for peak shape
    :param file_name_peak_height: the file name for peak height
    :return:
    """
    file_path_os_x = os.path.join(save_dir, file_name_out_shape_x)
    file_path_os_y = os.path.join(save_dir, file_name_out_shape_y)
    file_path_ph = os.path.join(save_dir, file_name_peak_height)
    file_path_ps = os.path.join(save_dir, file_name_peak_shape)

    np.save(file_path_os_x, out_shape_x)
    np.save(file_path_os_y, out_shape_y)
    np.save(file_path_ph, peak_height)
    np.save(file_path_ps, peak_shape)


os_cp_list, ph_cp_list, ps_cp_list = load_control_points(DROP_OUT_SHAPE_CONTROL_POINTS, DROP_PEAK_HEIGHT_CONTROL_POINTS, DROP_PEAK_SHAPE_CONTROL_POINTS)
c_os_x, c_os_y, c_ps, c_ph = collect_generated_shapes(os_cp_list, ph_cp_list, ps_cp_list, 1000, 10)
save_shapes(c_os_x, c_os_y, c_ps, c_ph,
            SAVE_DIR_OF_COLLECTED_POINTS,
            OUT_SHAPE_POINTS_X_FILE_NAME, OUT_SHAPE_POINTS_Y_FILE_NAME,
            OUT_PEAK_SHAPE_POINTS_FILE_NAME, OUT_PEAK_HEIGHT_POINTS_FILE_NAME)
print("complete!")
